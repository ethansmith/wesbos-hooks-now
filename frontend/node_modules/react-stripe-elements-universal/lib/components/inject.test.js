'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // @noflow


var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _enzyme = require('enzyme');

var _inject = require('./inject');

var _inject2 = _interopRequireDefault(_inject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

describe('injectStripe()', function () {
  var WrappedComponent = void 0;
  var context = void 0;
  var createSource = void 0;
  var createToken = void 0;
  var elementMock = void 0;

  beforeEach(function () {
    createSource = jest.fn();
    createToken = jest.fn();
    elementMock = {
      type: 'card',
      element: {
        on: jest.fn()
      }
    };
    context = {
      stripe: {
        elements: jest.fn(),
        createSource: createSource,
        createToken: createToken
      },
      registeredElements: [elementMock]
    };
    WrappedComponent = function WrappedComponent() {
      return _react2.default.createElement('div', null);
    };
    WrappedComponent.displayName = 'WrappedComponent';
  });

  it('sets the correct displayName', function () {
    expect((0, _inject2.default)(WrappedComponent).displayName).toBe('InjectStripe(WrappedComponent)');
  });

  it("includes the original component's displayName", function () {
    WrappedComponent.displayName = 'foo';
    expect((0, _inject2.default)(WrappedComponent).displayName).toBe('InjectStripe(foo)');
  });

  it("falls back to the original component's name if no displayName is set", function () {
    WrappedComponent.displayName = undefined;
    expect((0, _inject2.default)(WrappedComponent).displayName).toBe('InjectStripe(' + WrappedComponent.name + ')');
  });

  it('throws when StripeProvider is missing from ancestry', function () {
    // Prevent the expected console.error from react to keep the test output clean
    var originalConsoleError = global.console.error;
    global.console.error = function (msg) {
      if (!msg.startsWith('Warning: Failed context type: The context `stripe` is marked as required')) {
        originalConsoleError(msg);
      }
    };

    var Injected = (0, _inject2.default)(WrappedComponent());

    expect(function () {
      return (0, _enzyme.shallow)(_react2.default.createElement(Injected, null));
    }).toThrow(/It looks like you are trying to inject Stripe context outside of an Elements context/);
    global.console.error = originalConsoleError;
  });

  it('renders <WrappedComponent> with `stripe` prop', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    expect(props).toHaveProperty('stripe');
    expect(props).toHaveProperty('stripe.createSource');
    expect(props).toHaveProperty('stripe.createToken');
  });

  it('props.stripe.createToken calls createToken with element and empty options when called with no arguments', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    props.stripe.createToken();
    expect(createToken).toHaveBeenCalledWith(elementMock.element, {});
  });

  it('props.stripe.createToken calls createToken with element and options when called with options object', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    props.stripe.createToken({ foo: 'bar' });
    expect(createToken).toHaveBeenCalledWith(elementMock.element, {
      foo: 'bar'
    });
  });

  it('props.stripe.createToken calls createToken with string as first argument and options object as second', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    props.stripe.createToken('test', { foo: 'bar' });
    expect(createToken).toHaveBeenCalledWith('test', { foo: 'bar' });
  });

  it('props.stripe.createToken throws when called with invalid options type', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    expect(function () {
      return props.stripe.createToken(1);
    }).toThrow('Invalid options passed to createToken. Expected an object, got number.');
  });

  it('props.stripe.createToken throws when no element is in the tree', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: _extends({}, context, {
        registeredElements: []
      })
    });

    var props = wrapper.props();
    expect(function () {
      return props.stripe.createToken();
    }).toThrow(/We could not infer which Element you want to use for this operation./);
  });

  it('props.stripe.createSource calls createSource with element and empty options when called with no arguments', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    props.stripe.createSource();
    expect(createSource).toHaveBeenCalledWith(elementMock.element, {});
  });

  it('props.stripe.createSource calls createSource with options', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    props.stripe.createSource({ type: 'card', foo: 'bar' });
    expect(createSource).toHaveBeenCalledWith(elementMock.element, {
      foo: 'bar'
    });
  });

  it('props.stripe.createSource calls createSource with options when called with unknown type', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    props.stripe.createSource({ type: 'baz', foo: 'bar' });
    expect(createSource).toHaveBeenCalledWith({ type: 'baz', foo: 'bar' });
  });

  it('props.stripe.createSource throws when called with invalid options argument', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: context
    });

    var props = wrapper.props();
    expect(function () {
      return props.stripe.createSource(1);
    }).toThrow('Invalid options passed to createSource. Expected an object, got number.');
  });

  it('props.stripe.createSource throws when called without element/source-type and no elements are in the tree', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: _extends({}, context, {
        registeredElements: []
      })
    });

    var props = wrapper.props();
    expect(function () {
      return props.stripe.createSource();
    }).toThrow(/You did not specify the type of Source to create/);
  });

  it('props.stripe.createSource throws when called with source type that matches multiple elements', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: _extends({}, context, {
        registeredElements: [{
          type: 'card',
          element: {
            on: jest.fn()
          }
        }, {
          type: 'card',
          element: {
            on: jest.fn()
          }
        }]
      })
    });

    var props = wrapper.props();
    expect(function () {
      return props.stripe.createSource({ type: 'card' });
    }).toThrow(/We could not infer which Element you want to use for this operation/);
  });

  it('props.stripe.createSource throws when called with no source type and tree has multiple elements', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.shallow)(_react2.default.createElement(Injected, null), {
      context: _extends({}, context, {
        registeredElements: [{
          type: 'card',
          element: {
            on: jest.fn()
          }
        }, {
          type: 'card',
          element: {
            on: jest.fn()
          }
        }]
      })
    });

    var props = wrapper.props();
    expect(function () {
      return props.stripe.createSource();
    }).toThrow(/We could not infer which Element you want to use for this operation/);
  });

  it('throws when `getWrappedInstance` is called without `{withRef: true}` option.', function () {
    var Injected = (0, _inject2.default)(WrappedComponent);

    var wrapper = (0, _enzyme.mount)(_react2.default.createElement(Injected, null), {
      context: context
    });

    expect(function () {
      return wrapper.node.getWrappedInstance();
    }).toThrow('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');
  });

  it('`getWrappedInstance` works whith `{withRef: true}` option.', function () {
    // refs won't work with stateless functional components
    var WrappedClassComponent = function (_React$Component) {
      _inherits(WrappedClassComponent, _React$Component);

      function WrappedClassComponent() {
        _classCallCheck(this, WrappedClassComponent);

        return _possibleConstructorReturn(this, (WrappedClassComponent.__proto__ || Object.getPrototypeOf(WrappedClassComponent)).apply(this, arguments));
      }

      _createClass(WrappedClassComponent, [{
        key: 'render',
        value: function render() {
          return _react2.default.createElement(
            'div',
            null,
            this.foo
          );
        }
      }]);

      return WrappedClassComponent;
    }(_react2.default.Component);

    WrappedClassComponent.displayName = 'WrappedClassComponent';


    var Injected = (0, _inject2.default)(WrappedClassComponent, { withRef: true });

    var wrapper = (0, _enzyme.mount)(_react2.default.createElement(Injected, null), {
      context: context
    });

    expect(wrapper.node.getWrappedInstance() instanceof WrappedClassComponent).toBe(true);
  });
});